## Java的演进之路（9~24新特性）

### Java8时代的落幕

![](C:\Users\Administrator\AppData\Roaming\marktext\images\2025-07-08-10-44-34-image.png)

![](C:\Users\Administrator\AppData\Roaming\marktext\images\2025-07-08-10-46-26-image.png)

![](C:\Users\Administrator\AppData\Roaming\marktext\images\2025-07-08-10-45-48-image.png)

> Java之父高斯林曾就公开建议赶紧升级到Java17，因为JDK17是一个比Java8更好的版本！

![](C:\Users\Administrator\AppData\Roaming\marktext\images\2025-07-08-10-46-46-image.png)

> 新版任你发，我用 Java 8？
> 
> 从目前的一些消息来看，Java8 似乎正在退场。留给java 8用户的时间不多了……



### Java新历程

#### JDK9

##### 模块化系统

![](C:\Users\Administrator\AppData\Roaming\marktext\images\2025-07-08-17-01-17-image.png)

        将JDK拆分为94个模块，解决JAR Hell问题（依赖冲突、遮蔽）。每个模块声明依赖（`requires`）和导出包（`exports`），JVM按需加载模块，减少内存占用（启动时内存降低30~60MB）

```java
// module-info.java
module com.example.app {
    requires java.sql;      // 声明依赖
    exports com.example.util; // 导出包
}
```

在 Oracle 官方中为 `Java 9` 中的模块系统的定义如下：

> the module, which is a named, self-describing collection of code and data. This module system.

直白翻译：模块是一个命名的，自我描述的代码和数据的集合。

`Java 9` 不仅支持了模块化开发，更是直接把 `JDK` 自身进行了模块化处理。`JDK` 自身的模块化可以带来很多好处，比如：

- 方便管理，越来越大的 JDK 在模块化下结构变得更加清晰。
- 模块化 JDK 和 JRE 运行时镜像可以提高性能、安全性、维护性。
- 可以定制 JRE，使用更小的运行时镜像，比如网络应用不需要 swing 库(java.awt)，可以在打包时选择不用，减少性能消耗。
- 清晰明了的模块调用关系，避免调用不当出来的各种问题。

上面提到了 JDK 自身的模块化，我们通过浏览 JDK 9 的目录结构也可以发现一些变化。



![](C:\Users\Administrator\AppData\Roaming\marktext\images\2025-07-08-12-01-25-image.png)

![](C:\Users\Administrator\AppData\Roaming\marktext\images\2025-07-08-12-01-36-image.png)

##### 模块化使用

         模块化是将大型软件系统拆分成一系列更小的单元，每个单元内部包含其自身的代码和数据，同时明确与其他模块的依赖关系。模块化提供了封装边界，使得代码组织更加清晰，也可以降低系统复杂度，提高代码的复用性。

    Java模块由模块声明文件 `module-info.java` 定义，它位于模块的根包下，并声明了模块的名称、依赖关系以及对其他模块公开的包。通过使用 `module` 关键字来声明模块，开发者可以精确控制模块间的交互和依赖。

```java
// module app
requires pay;

uses com.pay.PayService;

// module pay
exports com.pay;

provides com.pay.PayService with com.pay.WeChatPayServiceImpl
```

##### String实现由char[]改成byte[]

官方描述

以下是官方文档中的描述（原文）：

> “The current implementation of String uses a char array to store the string value. This change proposes to modify the internal representation of the String class to use a byte array instead of a char array. This will reduce the memory footprint of the String class by 50% for strings that contain only Latin-1 characters.”

翻译为：

> “当前 String 类的实现使用 char 数组存储字符串值。此变更建议将 String 类的内部表示从 char 数组改为 byte 数组。对于仅包含 Latin-1 字符的字符串，这一改动将减少 String 类的内存占用 50%。”

1.**`char` 类型的代价：**

- 在Java中，`char` 类型代表一个UTF-16代码单元，占用 **2个字节 (16位)**。

- JDK 8及之前的`String`内部使用`char[]`存储字符数据。这意味着**每一个字符，无论它实际需要多少字节编码（比如ASCII字符只需要1个字节），在内存中都固定占用2个字节**

2.**现实世界的字符串特性：**

- 大量的实际应用（Web服务、业务系统、配置文件处理、日志等）中处理的字符串内容，**绝大部分字符都在[Latin-1 (ISO-8859-1) 编码范围]()内（即码点值 <= 255）**。这些字符包括：
  
  - 所有ASCII字符（英文字母、数字、常用符号）
  
  - 西欧语言字符（带重音符号的字母等）

- 对于这些字符，**1个字节就足够存储**。使用`char[]`（每个字符2字节）造成了**巨大的内存浪费**。

**Java 8 中的实现**

在 Java 8 中，String 类的底层实现如下：

```java
public final class String {
    private final char[] value;
    private final int offset;
    private final int count;
    private int hash; // Cache for hash code
}
```

- `value`：存储字符串的字符数组。
- `offset`：字符串在数组中的起始位置。
- `count`：字符串的长度。

每个字符占用 2 个字节，因此存储空间为 `2 * count` 字节。

**Java 9 中的实现**

**byte[] + 编码标志的优化方案 (Compact Strings)**：

- `String`内部不再总是使用`char[]`，而是改用`byte[]`。

- 同时，`String`对象内部增加了一个`coder`标志字段(一个`byte`类型)。
  
  - `coder = LATIN1` (0)：表示`byte[]`中的每个字节直接对应一个Latin-1字符（码点值 0-255）。此时**每个字符只占1字节**。
  
  - `coder = UTF16` (1)：表示`byte[]`中存储的是UTF-16编码（小端序）的数据，每两个字节（一个`char`）代表一个代码单元。此时字符占用与旧版`char[]`相同。

- **关键点：** `String`对象在**构造时**会根据其包含的字符**自动选择**最高效的编码方式（LATIN1或UTF16）。如果字符串中**所有**字符都在Latin-1范围内，就使用LATIN1编码（1字节/字符）；如果**存在任何一个**字符超出了Latin-1范围（例如中文字符、表情符号等），则整个字符串使用UTF16编码（2字节/字符）。

```java
public final class String {
    private final byte[] value;
    private final int coder;
}
```

- `value`：存储字符串的字节数组。
- `coder`：标识字符串的编码方式（`LATIN1` 或 `UTF16`）。

通过 `coder` 字段，Java 9 动态选择编码方式。如果字符串仅包含 Latin-1 字符，则使用 1 字节存储；否则使用 2 字节存储。

    **JDK 9 将 `String` 的底层存储从 `char[]` 改为 `byte[]` + `coder` 标志，最主要的目的是为了实施 "Compact Strings" 优化，通过为纯 Latin-1 字符的字符串使用单字节存储，显著降低此类字符串（在现实应用中占绝大多数）的内存占用（约减半），进而减少GC压力、提升缓存效率，最终在整体上提高应用的性能和可伸缩性。这项优化对开发者完全透明，其带来的内存节省效益在绝大多数场景下远超其引入的微小操作开销。**

##### 集合工厂方法

引入了便捷的集合创建方法：

```java
// 创建不可变集合
List<String> list = List.of("A", "B", "C");
Set<String> set = Set.of("X", "Y", "Z");
Map<String, Integer> map = Map.of("one", 1, "two", 2);

// 创建更大的不可变 Map
Map<String, Integer> map = Map.ofEntries(
    Map.entry("one", 1),
    Map.entry("two", 2),
    Map.entry("three", 3)
);
```

##### 接口私有方法

支持在接口中定义私有方法：

```java
public interface MyInterface {
    private String formatData(String data) {
        return "[" + data + "]";
    }
    
    default void printData(String data) {
        System.out.println(formatData(data));
    }
}
```

##### Stream API改进

新增了 Stream API 的便捷方法：

```java
// takeWhile 和 dropWhile
Stream.of(1, 2, 3, 4, 5)
      .takeWhile(n -> n < 4)
      .forEach(System.out::println); // 输出 1, 2, 3

// iterate 方法支持 Predicate
Stream.iterate(1, n -> n < 100, n -> n * 2)
      .forEach(System.out::println);

// ofNullable 方法
Stream.ofNullable(null).count(); // 0
```

##### try-with-resources 改进

```java
@Test
void testTry() throws IOException {
  String fileName = "D:\data\test\testTry.txt";
  try(FileOutputStream fos = new FileOutputStream(fileName);
      OutputStreamWriter osw = new OutputStreamWriter(fos);
      BufferedWriter bw = new BufferedWriter(osw);){
    bw.write("IO管道流被自动调用close()方法");
    bw.flush();
  }
}
```

```java
@Test
void testJava9Try() throws IOException {
  String fileName = "D:\data\test\testJava9Try.txt";

  FileOutputStream fos = new FileOutputStream(fileName);
  OutputStreamWriter osw = new OutputStreamWriter(fos);
  BufferedWriter bw = new BufferedWriter(osw);

  try(bw;osw;fos){
    bw.write("Java9-可以被自动调用close()方法");
    bw.flush();
  }
}
```

#### JDK10

##### 局部变量类型推断

引入了 var 关键字，支持局部变量类型推断：

```java
// 使用 var 声明局部变量
var list = new ArrayList<String>();
var stream = list.stream();
var map = Map.of("key", "value");

// 在 for 循环中使用
for (var item : list) {
    System.out.println(item);
}

// 在 try-with-resources 中使用
try (var reader = new BufferedReader(new FileReader("test.txt"))) {
    var line = reader.readLine();
    System.out.println(line);
}
```

#### JDK11(LTS)

##### Lambda 参数的局部变量语法

支持在 Lambda 表达式中使用 var：

```java
// 使用 var 在 Lambda 中声明参数
(var x, var y) -> x + y

// 添加注解
(@NotNull var x, @Nullable var y) -> x + y
```

##### String 新方法

String 类增加了多个实用方法：

```java
// 判断字符串是否为空白
"  ".isBlank();      // true
" abc ".isBlank();   // false

// 去除首尾空白 这里注意，`trim` 只能去除半角空格，而 `strip` 是去除各种空白符。
" abc ".strip();     // "abc"
" abc ".stripLeading();  // "abc "
" abc ".stripTrailing(); // " abc"

// 重复字符串
"abc".repeat(3);     // "abcabcabc"

// 行数统计
"a\nb\nc".lines().count();  // 3
```

##### 运行单文件代码

直接运行 Java 源文件

```java
// 直接运行源文件
java HelloWorld.java
```

##### File API

```java
// 创建临时文件
Path path = Files.writeString(Files.createTempFile("test", ".txt"), "https://www.baidu.com");
System.out.println(path);
// 读取文件
// String ss = Files.readString(Path.of("file.json"));
String s = Files.readString(path);
System.out.println(s);

// 结果
// https://www.baidu.com
```

#### JDK17(LTS)

##### 密封类(Sealed Classes)

密封类可以对继承或者实现他们的类进行限制。

```java
public sealed class Shape permits Circle, Square {
    private String color;

    public Shape(String color) {
        this.color = color;
    }

    public String getColor() {
        return color;
    }
}

public final class Circle extends Shape {
    private double radius;

    public Circle(String color, double radius) {
        super(color);
        this.radius = radius;
    }

    // 其他Circle特有的方法
}

public final class Square extends Shape {
    private double side;

    public Square(String color, double side) {
        super(color);
        this.side = side;
    }

    // 其他Square特有的方法
}
```

主要优点：

- 精确控制类型层次结构
- 增强代码安全性和可维护性
- 与模式匹配完美配合
- 支持接口和类的密封

##### 文本块

**多行字符串字面量的引入**: 文本块允许编写跨越多行的字符串而不需手动添加换行符或转义字符。这对于构建HTML、SQL查询或其他格式化文本非常有用。

![](C:\Users\Administrator\AppData\Roaming\marktext\images\2025-07-08-20-06-59-image.png)

#### JDK21(LTS)

##### 虚拟线程

```java
public class VirtualThreadDemo {
    public static void main(String[] args) throws Exception {
        // 创建单个虚拟线程
        Thread vThread = Thread.startVirtualThread(() -> {
            System.out.println("在虚拟线程中运行");
        });
        
        // 使用虚拟线程执行器
        try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {
            // 提交大量任务
            IntStream.range(0, 10_000).forEach(i -> {
                executor.submit(() -> {
                    // 模拟数据库操作
                    processDatabase(i);
                    return i;
                });
            });
        }
        
        // 使用结构化并发
        try (var scope = new StructuredTaskScope.ShutdownOnFailure()) {
            // 并行执行多个微服务调用
            Future<String> service1 = scope.fork(() -> callMicroservice("service1"));
            Future<String> service2 = scope.fork(() -> callMicroservice("service2"));
            Future<String> service3 = scope.fork(() -> callMicroservice("service3"));
            
            try {
                scope.join();           // 等待所有任务完成
                scope.throwIfFailed();  // 如果有任务失败则抛出异常
                
                // 处理结果
                processResults(
                    service1.resultNow(),
                    service2.resultNow(),
                    service3.resultNow()
                );
            } catch (Exception e) {
                System.err.println("服务调用失败：" + e.getMessage());
                throw e;
            }
        }
    }
    
    // 模拟数据库操作
    private static void processDatabase(int id) {
        try {
            // 模拟网络延迟
            Thread.sleep(Duration.ofMillis(100));
            System.out.printf("处理数据库记录 %d%n", id);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new RuntimeException(e);
        }
    }
    
    // 模拟微服务调用
    private static String callMicroservice(String name) throws Exception {
        // 模拟网络延迟
        Thread.sleep(Duration.ofMillis(200));
        return name + " 响应";
    }
    
    // 处理微服务结果
    private static void processResults(String... results) {
        System.out.println("处理服务响应：" + String.join(", ", results));
    }
    
    // 展示虚拟线程与平台线程的区别
    static void threadComparison() throws Exception {
        // 使用平台线程
        try (var executor = Executors.newFixedThreadPool(100)) {
            // 提交任务...
        }
        
        // 使用虚拟线程
        try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {
            // 提交任务...
        }
        
        // 虚拟线程的线程本地变量
        ThreadLocal<String> threadLocal = new ThreadLocal<>();
        Thread.startVirtualThread(() -> {
            threadLocal.set("虚拟线程的值");
            System.out.println(threadLocal.get());
        }).join();
    }
}
```

主要特点：

- 轻量级线程实现
- 高效的并发处理
- 自动线程管理
- 与现有代码兼容
- 改进的性能和可伸缩性

##### Records

```java
public class Jep440Record {
    public static void main(String[] args) {

        Dog dog = new Dog("Husky", 1);
        if (dog instanceof Dog(String name, int age)) {
            String res = StringTemplate.STR."name：\{name} age：\{age}";
            System.out.println(res);
        }
      
    }
}
record Dog(String name, int age) {}
```

##### switch 模式匹配

```java
public class Jep441SwitchPatten {

    public static void main(String[] args) {
        String r1 = formatterPatternSwitch(Integer.valueOf(1));
        String r2 = formatterPatternSwitch(new String("www.baidu.com"));
        String r3 = formatterPatternSwitch(Double.valueOf(3.14D));
        System.out.println(r1);
        System.out.println(r2);
        System.out.println(r3);
    }

    static String formatterPatternSwitch(Object obj) {
        return switch (obj) {
            case Integer i -> String.format("int %d", i);
            case Long l    -> String.format("long %d", l);
            case Double d  -> String.format("double %f", d);
            case String s  -> String.format("String %s", s);
            default        -> obj.toString();
        };
    }
}
```

Java 21 中 switch 还可以用于 `null` 判断。

```java
static void testFooBarNew(String s) {
    switch (s) {
        case null         -> System.out.println("Oops");
        case "Foo", "Bar" -> System.out.println("Great");
        default           -> System.out.println("Ok");
  }
}
```

#### JDK24

- **虚拟线程（Virtual Threads）**：轻量级线程，由 JVM 管理。
- **结构化并发（Structured Concurrency）**：任务并行管理。
- **作用域值（ScopedValue）**：替代 ThreadLocal 的更安全上下文传递方式。
1. JEP 404：分代 Shenandoah（实验性）
2. JEP 450：紧凑对象标头（实验性）
3. JEP 472：准备限制 JNI 的使用
4. JEP 475： G1 的 Late Barrier 扩展
5. JEP 478：密钥派生函数 API（预览）
6. JEP 479：删除 Windows 32 位 x86 端口
7. JEP 483：提前类加载和链接
8. JEP 484：类文件 API
9. JEP 485：流收集器
10. JEP 486：永久禁用安全管理器
11. JEP 487：范围值（第四个预览版）
12. JEP 488：模式中的原始类型、instanceof 和 switch（第二个预览）
13. JEP 489：向量 API（第九个孵化器）
14. JEP 490：ZGC：删除非分代模式
15. JEP 491：无需固定即可同步虚拟线程
16. JEP 492：灵活的构造函数主体（第三次预览）
17. JEP 493：无需 JMOD 即可链接运行时图像
18. JEP 494：模块导入声明（第二预览版）
19. JEP 495：简单源文件和实例主要方法（第四个预览版）
20. JEP 496：基于抗量子模块格的密钥封装机制
21. JEP 497：基于模块格的抗量子数字签名算法
22. JEP 498：在 sun.misc.Unsafe 中使用内存访问方法时发出警告
23. JEP 499：结构化并发（第四个预览版）
24. JEP 501：弃用 32 位 x86 端口并将其删除












